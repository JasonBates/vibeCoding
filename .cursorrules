# Cursor Rules for vibeCoding Project

## ğŸ Virtual Environment (CRITICAL)
- ALWAYS activate the virtual environment before running any Python commands
- The virtual environment is located at `.venv/` in the project root
- Use `source .venv/bin/activate` before running any Python scripts, tests, or package installations
- This is critical for the project to work correctly and prevents dependency conflicts

## ğŸ“ Project Architecture
- **Type**: Python Streamlit application with OpenAI API integration
- **Database**: Supabase for haiku storage and retrieval
- **Testing**: Comprehensive test suite (unit, integration, CI/CD)
- **Code Quality**: Pre-commit hooks with black, isort, flake8, pytest
- **Structure**: Modular design with separate services, models, and repository layers

## ğŸš€ Development Workflow
### Essential Commands (always activate venv first)
```bash
# Activate environment
source .venv/bin/activate

# Run tests
python3 scripts/run_ci_tests.py  # Full CI test suite
pytest                          # Quick test run

# Run application
streamlit run streamlit_app.py

# Install dependencies
pip install -r requirements.txt
```

## ğŸ”’ Security Best Practices
- **Input Sanitization**: Always escape user input before HTML rendering (use `html.escape()`)
- **Secrets Management**: Store API keys in `.env` file, never hardcode credentials
- **XSS Prevention**: Validate and escape all user-provided data before display
- **SQL Injection**: Use parameterized queries when interacting with Supabase
- **Environment Variables**: Use `os.getenv()` for configuration, never hardcode sensitive data

## ğŸ¨ Streamlit Best Practices
- **Caching**: Use `@st.cache_data` for expensive computations and API calls
- **Session State**: Use `st.session_state` for maintaining state across reruns
- **Error Handling**: Implement try-catch blocks for API calls and user interactions
- **UI Components**: Use `st.container()` for better layout control
- **Performance**: Minimize reruns by using `st.rerun()` strategically
- **Secrets**: Access Supabase credentials via `st.secrets` when available

## ğŸ—„ï¸ Supabase Integration
- **Connection**: Use environment variables for URL and key configuration
- **Error Handling**: Always check if storage service is available before operations
- **Data Validation**: Validate haiku data before saving to database
- **Repository Pattern**: Use the repository layer for all database operations
- **Testing**: Mock Supabase calls in unit tests, use real connection in integration tests

## ğŸ§ª Testing Strategy
- **Unit Tests**: Test individual functions and classes in isolation
- **Integration Tests**: Test API integrations and database operations
- **CI Tests**: Run full test suite with coverage reporting
- **Mocking**: Use `unittest.mock` for external dependencies
- **Coverage**: Maintain minimum 60% test coverage
- **Test Data**: Use fixtures and factories for consistent test data

## ğŸ“Š CI/CD Pipeline
- **Pre-commit**: Code formatting, linting, and basic tests
- **GitHub Actions**: Automated testing on push/PR
- **Coverage**: Fail builds if coverage drops below threshold
- **Security**: Check for vulnerabilities in dependencies
- **Quality Gates**: All tests must pass before merge

## ğŸ—ï¸ Code Architecture
- **Separation of Concerns**: Keep UI, business logic, and data access separate
- **Service Layer**: Use service classes for business logic (e.g., `HaikuService`)
- **Repository Pattern**: Abstract data access behind repository interfaces
- **Model Classes**: Use Pydantic or dataclasses for data validation
- **Error Handling**: Implement custom exceptions for different error types

## ğŸ“ Code Quality Standards
- **Style**: Follow PEP 8, use black for formatting
- **Imports**: Use isort for import organization
- **Linting**: Use flake8 for code quality checks
- **Type Hints**: Use type annotations for better code documentation
- **Docstrings**: Write clear docstrings for all public functions
- **Comments**: Explain complex business logic, not obvious code

## ğŸ”§ Development Tools
- **Pre-commit**: Automated code quality checks
- **Pytest**: Testing framework with fixtures and parametrization
- **Coverage**: Code coverage measurement and reporting
- **Black**: Code formatting
- **isort**: Import sorting
- **flake8**: Linting and style checking

## ğŸš¨ Common Pitfalls to Avoid
- **Never run Python commands without activating venv**
- **Don't hardcode API keys or sensitive data**
- **Always escape user input before HTML rendering**
- **Don't commit without running tests**
- **Avoid direct database queries in UI components**
- **Don't ignore pre-commit hook failures**
- **Always handle exceptions gracefully**

## ğŸ“‹ Pre-commit Checklist
1. âœ… Activate virtual environment
2. âœ… Run `python3 scripts/run_ci_tests.py`
3. âœ… Check for security vulnerabilities
4. âœ… Verify all tests pass
5. âœ… Ensure code follows style guidelines
6. âœ… Update documentation if needed

## ğŸ¯ Performance Optimization
- **Caching**: Cache expensive operations and API responses
- **Lazy Loading**: Load data only when needed
- **Connection Pooling**: Reuse database connections
- **Memory Management**: Clean up large objects and temporary data
- **Async Operations**: Use async/await for I/O operations when possible

## ğŸ” Debugging Guidelines
- **Logging**: Use Python's logging module for debugging
- **Error Messages**: Provide clear, actionable error messages
- **Stack Traces**: Include relevant context in error handling
- **Testing**: Write tests that reproduce bugs before fixing them
- **Documentation**: Document known issues and workarounds
